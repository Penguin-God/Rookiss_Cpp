#include <iostream>
using namespace std;

// 프로그래밍을 단순하게 생각하면 데이터를 저장하고 가공하는 것. (사실상 모든 것이 데이터니까)
// 가공 부분이 로직인 느낌

int main()
{
    // 어셈블리어 관점에서 보면 초깃값이 있다면 .data영역으로
    // 초깃값이 0이거나 없다면 .bss영역에서 저장함
    // 근데 몰라도 됨. 거의 다 모름
    int a = 100;

    // bool의 내부는 1바이트 정수.
    // 사실 1bit만 쓰기는 하는데 최소 연산 단위가 1바이트라서 그냥 1바이트로 잡은거
    bool isCpp = true;

    // 컴퓨터에서 실수를 표현할 때는 부동소수점이라는 방법을 사용함
    // 부동 소수점 : .을 유동적으로 움직여서 숫자를 표현하는 방법
    // 1) 정규화 3.1415926535 * 10
    // 2) 유효숫자와 지수로 구분. 31415926535(유효 숫자), 1(지수)
    // 부동소수점은 '근사값'이다.
    // 실수 2개를 비교할때는 2개가 '같다'고 가정하고 비교하면 안되고 오차값을 고려해야 한다.
    float b = 3.14f;

    // 영어 말고 전 세계 언어를 나타내기 위한 규약이 유니코드
    // UTF-8
    // 영어 숫자는 아스키코드로 표현(1바이트)
    // 유럽 지역의 문자는 2바이트
    // 한글, 한자는 3바이트
    // UTF-16
    // 대부분의 글자가 2바이트 고정
    // UTF-8은 영어권에서 사용 시 강점이 있고 UTF-16은 아시아권이나 문자 크기 비교시 강점이 있음
    char c = 'c';

    // 문자열의 끝은 NULL (0) 이어야 함
    char str[] = { 'c', 'p', 'p', '\0' };
    char str2[] = "cpp"; // \0을 자동으로 넣어줌
    cout << "Hello Int : " << str << endl;
    cout << "Hello Int : " << str2 << endl;

    // a++연산
    int test1 = 1;
    test1++;
    // ++a 연산
    ++test1;

    // 대입 ++연산 비교
    int test2 = 1;
    test2 = test1++;
    test2 = ++test1;

    // << 그냥 왼쪽으로 미는거. 이때 비트연산 맨 왼쪽에 1이 있으면 절벽으로 밀어서 떨어뜨리는 것처럼 없애버림
    // >> 그냥 오른쪽으로 미는거. 맨 끝쪽에 있는애 없애는건 똑같음. 허나 2의 보수를 사용 중이라면 걔를 1로 남겨두고 옮긴만큼 복사함 ㅋㅋㅋㅋ.
    // ex) 1000'0000 >>^2 = 1110'0000. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
    // 이거 때문에 bitflag할떄는 unsigned를 써서 음의 보수를 지워서 사용함

    int bit = 0;
    const int stun = 3;
    bit = 1 << stun;
}

// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
